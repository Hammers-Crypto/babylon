package keeper_test

import (
	"fmt"
	"math/rand"
	"testing"

	"github.com/babylonchain/babylon/x/epoching/types"
	sdk "github.com/cosmos/cosmos-sdk/types"
	"github.com/cosmos/cosmos-sdk/types/query"
	"github.com/stretchr/testify/require"
)

func (suite *KeeperTestSuite) TestParamsQuery() {
	ctx, queryClient := suite.ctx, suite.queryClient
	req := types.QueryParamsRequest{}

	testCases := []struct {
		msg    string
		params types.Params
	}{
		{
			"default params",
			types.DefaultParams(),
		},
	}

	for _, tc := range testCases {
		suite.Run(fmt.Sprintf("Case %s", tc.msg), func() {
			wctx := sdk.WrapSDKContext(ctx)
			resp, err := queryClient.Params(wctx, &req)
			suite.NoError(err)
			suite.Equal(&types.QueryParamsResponse{Params: tc.params}, resp)
		})
	}
}

// FuzzParamsQuery fuzzes queryClient.Params
// 1. Generate random param and a flag
// 2. If the flag is true, set the param in the keeper
// 3. Send the query to get the current param
// 4. If the flag is true, verify if the returned param is the set one, otherwise the default one
func FuzzParamsQuery(f *testing.F) {
	f.Add(uint64(11111), int64(23))
	f.Add(uint64(22222), int64(330))
	f.Add(uint64(22222), int64(101))

	f.Fuzz(func(t *testing.T, epochInterval uint64, seed int64) {
		rand.Seed(seed)
		// ensure EpochInterval is nonzero
		if epochInterval == 0 {
			epochInterval = uint64(rand.Int())
		}

		// params generated by fuzzer
		params := types.DefaultParams()
		params.EpochInterval = epochInterval

		// test the case of EpochInterval == 0
		zeroIntervalFlag := rand.Intn(2)
		if zeroIntervalFlag == 0 {
			params.EpochInterval = 0
			// validation should not pass with zero EpochInterval
			require.Error(t, params.Validate())
			// set EpochInterval to nonzero again
			params.EpochInterval = uint64(rand.Int())
		}

		_, ctx, keeper, _, queryClient := setupTestKeeper()
		wctx := sdk.WrapSDKContext(ctx)
		// if setParamsFlag == 0, set params
		setParamsFlag := rand.Intn(2)
		if setParamsFlag == 0 {
			keeper.SetParams(ctx, params)
		}
		req := types.QueryParamsRequest{}
		resp, err := queryClient.Params(wctx, &req)
		require.NoError(t, err)
		// if setParamsFlag == 0, resp.Params should be changed, otherwise default
		if setParamsFlag == 0 {
			require.Equal(t, params, resp.Params)
		} else {
			require.Equal(t, types.DefaultParams(), resp.Params)
		}
	})
}

func (suite *KeeperTestSuite) TestCurrentEpoch() {
	ctx, queryClient := suite.ctx, suite.queryClient
	req := types.QueryCurrentEpochRequest{}

	testCases := []struct {
		msg           string
		malleate      func()
		epochNumber   sdk.Uint
		epochBoundary sdk.Uint
	}{
		{
			"epoch 0",
			func() {},
			sdk.NewUint(0),
			sdk.NewUint(0),
		},
		{
			"epoch 1",
			func() {
				suite.keeper.IncEpochNumber(suite.ctx)
			},
			sdk.NewUint(1),
			sdk.NewUint(suite.keeper.GetParams(suite.ctx).EpochInterval * 1),
		},
		{
			"epoch 2",
			func() {
				suite.keeper.IncEpochNumber(suite.ctx)
			},
			sdk.NewUint(2),
			sdk.NewUint(suite.keeper.GetParams(suite.ctx).EpochInterval * 2),
		},
		{
			"reset to epoch 0",
			func() {
				suite.keeper.InitEpochNumber(suite.ctx)
			},
			sdk.NewUint(0),
			sdk.NewUint(0),
		},
	}

	for _, tc := range testCases {
		suite.Run(fmt.Sprintf("Case %s", tc.msg), func() {
			tc.malleate()
			wctx := sdk.WrapSDKContext(ctx)
			resp, err := queryClient.CurrentEpoch(wctx, &req)
			suite.NoError(err)
			suite.Equal(tc.epochNumber.Uint64(), resp.CurrentEpoch)
			suite.Equal(tc.epochBoundary.Uint64(), resp.EpochBoundary)
		})
	}
}

// FuzzCurrentEpoch fuzzes queryClient.CurrentEpoch
// 1. generate a random number of epochs to increment
// 2. query the current epoch and boundary
// 3. compare them with the correctly calculated ones
func FuzzCurrentEpoch(f *testing.F) {
	f.Add(uint64(1111))
	f.Add(uint64(2222))
	f.Add(uint64(3333))

	f.Fuzz(func(t *testing.T, increment uint64) {
		_, ctx, keeper, _, queryClient := setupTestKeeper()
		wctx := sdk.WrapSDKContext(ctx)
		for i := uint64(0); i < increment; i++ {
			keeper.IncEpochNumber(ctx)
		}
		req := types.QueryCurrentEpochRequest{}
		resp, err := queryClient.CurrentEpoch(wctx, &req)
		require.NoError(t, err)
		require.Equal(t, increment, resp.CurrentEpoch)
		require.Equal(t, increment*keeper.GetParams(ctx).EpochInterval, resp.EpochBoundary)
	})
}

func (suite *KeeperTestSuite) TestEpochMsgs() {
	ctx, queryClient := suite.ctx, suite.queryClient
	wctx := sdk.WrapSDKContext(ctx)
	req := &types.QueryEpochMsgsRequest{
		Pagination: &query.PageRequest{
			Limit: 100,
		},
	}

	testCases := []struct {
		msg       string
		malleate  func()
		epochMsgs []*types.QueuedMessage
	}{
		{
			"empty epoch msgs",
			func() {},
			[]*types.QueuedMessage{},
		},
		{
			"newly inserted epoch msg",
			func() {
				msg := types.QueuedMessage{
					TxId: []byte{0x01},
				}
				suite.keeper.EnqueueMsg(suite.ctx, msg)
			},
			[]*types.QueuedMessage{
				{TxId: []byte{0x01}},
			},
		},
		{
			"newly inserted epoch msg",
			func() {
				msg := types.QueuedMessage{
					TxId: []byte{0x02},
				}
				suite.keeper.EnqueueMsg(suite.ctx, msg)
			},
			[]*types.QueuedMessage{
				{TxId: []byte{0x01}},
				{TxId: []byte{0x02}},
			},
		},
		{
			"cleared epoch msg",
			func() {
				suite.keeper.ClearEpochMsgs(suite.ctx)
			},
			[]*types.QueuedMessage{},
		},
	}

	for _, tc := range testCases {
		suite.Run(fmt.Sprintf("Case %s", tc.msg), func() {
			tc.malleate()
			resp, err := queryClient.EpochMsgs(wctx, req)
			suite.NoError(err)
			suite.Equal(len(tc.epochMsgs), len(resp.Msgs))
			suite.Equal(uint64(len(tc.epochMsgs)), suite.keeper.GetQueueLength(suite.ctx).Uint64())
			for idx := range tc.epochMsgs {
				suite.Equal(tc.epochMsgs[idx].MsgId, resp.Msgs[idx].MsgId)
				suite.Equal(tc.epochMsgs[idx].TxId, resp.Msgs[idx].TxId)
			}
		})
	}
}

// FuzzEpochMsgs fuzzes queryClient.EpochMsgs
// 1. randomly generate msgs and limit in pagination
// 2. check the returned msg was previously enqueued
// NOTE: Msgs in QueryEpochMsgsResponse are out-of-roder
func FuzzEpochMsgs(f *testing.F) {
	f.Add(int64(12))
	f.Add(int64(44))
	f.Add(int64(422))
	f.Add(int64(4222))

	f.Fuzz(func(t *testing.T, seed int64) {
		rand.Seed(seed)
		numMsgs := uint64(rand.Int() % 100)
		limit := uint64(rand.Int() % 100)

		txidsMap := map[string]bool{}
		_, ctx, keeper, _, queryClient := setupTestKeeper()
		wctx := sdk.WrapSDKContext(ctx)
		// enque a random number of msgs with random txids
		for i := uint64(0); i < numMsgs; i++ {
			txid := genRandomByteSlice(32)
			txidsMap[string(txid)] = true
			keeper.EnqueueMsg(ctx, types.QueuedMessage{TxId: txid})
		}
		// get epoch msgs
		req := types.QueryEpochMsgsRequest{
			Pagination: &query.PageRequest{
				Limit: limit,
			},
		}
		resp, err := queryClient.EpochMsgs(wctx, &req)
		require.NoError(t, err)

		require.Equal(t, min(uint64(len(txidsMap)), limit), uint64(len(resp.Msgs)))
		for idx := range resp.Msgs {
			_, ok := txidsMap[string(resp.Msgs[idx].TxId)]
			require.True(t, ok)
		}
	})
}
