syntax = "proto3";
package babylon.btccheckpoint.v1;

import "gogoproto/gogo.proto";

option go_package = "github.com/babylonchain/babylon/x/btccheckpoint/types";

// Consider we have a Merkle tree with following structure:
//            ROOT
//           /    \
//      H1234      H5555
//     /     \       \
//   H12     H34      H55
//  /  \    /  \     /
// H1  H2  H3  H4  H5
// L1  L2  L3  L4  L5
// To prove L3 was part of ROOT we need:
// - btc_transaction_index = 2 which in binary is 010
// (where 0 means going left, 1 means going right in the tree)
// - merkle_nodes we'd have H4 || H12 || H5555
// By looking at 010 we would know that H4 is a right sibling,
// H12 is left, H5555 is right again.
message BTCSpvProof {
  // Valid bitcoin transaction containing OP_RETURN opcode.
  bytes btc_transaction = 1;
  // Index of transaction within the block. Index is needed to determine if
  // currently hashed node is left or right.
  uint32 btc_transaction_index = 2;
  // List of concatenated intermediate merkle tree nodes, without root node and
  // leaf node against which we calculate the proof. Each node has 32 byte
  // length. Example proof can look like: 32_bytes_of_node1 || 32_bytes_of_node2
  // ||  32_bytes_of_node3 so the length of the proof will always be divisible
  // by 32.
  bytes merkle_nodes = 3;
  // Valid btc header which confirms btc_transaction.
  // Should have exactly 80 bytes
  bytes confirming_btc_header = 4
      [ (gogoproto.customtype) =
            "github.com/babylonchain/babylon/types.BTCHeaderBytes" ];
}

// Each provided OP_RETURN transaction can be idendtified by hash of block in
// which transaction was included and transaction index in the block
message TransactionKey {
  uint32 index = 1;
  bytes hash = 2 [
    (gogoproto.customtype) = "github.com/babylonchain/babylon/types.BTCHeaderHashBytes"
  ];
}

// Checkpoint can be composed from multiple transactions, so to identify whole
// submission we need list of transaction keys.
// Each submission can generally be identified by this list of (txIdx, blockHash)
// tuples.
// Note: this could possibly be optimized as if transactions were in one block
// they would have the same block hash and different indexes, but each blockhash
// is only 33 (1  byte for prefix encoding and 32 byte hash), so there should
// be other strong arguments for this optimization
message SubmissionKey {
  repeated TransactionKey key = 1;
}

enum BtcStatus {
  option (gogoproto.goproto_enum_prefix) = false;
  // SUBMITTED Epoch has Submitted btc status if there ever was at least one
  // known submission on btc main chain
  EPOCH_STATUS_SUBMITTED = 0 [(gogoproto.enumvalue_customname) = "Submitted"];
  // CONFIRMED Epoch has Confirmed btc status if there ever was at least one
  // known submission on btc main chain which was k-deep
  EPOCH_STATUS_CONFIRMED = 1 [(gogoproto.enumvalue_customname) = "Confirmed"];
  // CONFIRMED Epoch has Finalized btc status if there is was at exactly one
  // knon submission on btc main chain which is w-deep
  EPOCH_STATUS_FINALIZED = 2 [(gogoproto.enumvalue_customname) = "Finalized"];
}


// TODO: Determine if we should keep any block number or depth info.
// On one hand it may be usefull to determine if block is stable or not, on other
// depth/block number info, without context (i.e info about chain) is pretty useless
// and blockshash in enough to retrieve is from lightclient
message SubmissionData {
  // TODO: this could probably be better typed
  // Address of submitter of given checkpoint. Required to payup the reward to
  // submitter of given checkpoint
  bytes submitter = 1;
  // proofs is the two `BTCSpvProof`s corresponding to the submission
  // It is used for
  // - recovering address of sender of btc transction to payup the reward.
  // - allowing the ZoneConcierge module to prove the checkpoint is submitted to BTC
  repeated BTCSpvProof proofs = 2;
  uint64 epoch = 3;
}

// Data stored in db and indexed by epoch number
// TODO: Add btc blockheight at epooch end, when adding hadnling of epoching callbacks
message EpochData {
  // List of all received checkpoints during this epoch, sorted by order of
  // submission.
  repeated SubmissionKey key = 1;

  // Current btc status of the epoch
  BtcStatus status = 2;

  // Required to comunicate with checkpoint module about checkpoint status
  bytes raw_checkpoint = 3;
}

